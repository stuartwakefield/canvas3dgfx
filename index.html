<!DOCTYPE html>
<html>
	<head>
		<title>Canvas Graphics</title>
		<style>
			body {
				margin: 3em;
				background: #EEE;
				width: 640px;
				margin: 0 auto;
				font: 1em / 1.5em Calibri, Arial, Tahoma, Verdana, sans-serif;
			}
			h1, h2 {
				text-align: center;
			}
			canvas {
				background: #000;
				margin: 1em 0;
				width: 100%;
				display: block;
			}
		</style>
	</head>
	<body>
		<h2>Basic scaled projection</h2>
		<p>This projection simply discards the z-axis information and draws the x and y-axis coordinates for each of the model's triangles. The values are scaled from the models normalised values between -1.0 and 1.0 to the desired size in the projection space through multiplication.</p>
		<canvas id="canvas-1"></canvas>
		<h2>Orthographic projection</h2>
		<canvas id="canvas-2"></canvas>
		<h3>Cavalier projection</h3>
		<p>z length is preserved in scale</p>
		<canvas id="canvas-3"></canvas>
		<h3>Cabinet projection</h3>
		<p>z / 2</p>
		<canvas id="canvas-4"></canvas>
		<p>Or z * 2 / 3</p>
		<canvas id="canvas-5"></canvas>
		<h3>Isometric projection</h3>
		<canvas id="canvas-6"></canvas>
		<script>
			/*function Mat4(elements) {

				if (elements.length !== 16) {
					throw new Error('Mat4 must have 16 elements');
				}

				this.element = function(x, y) {

					if (x < 0 || x > 3) {
						throw new Error('x must be in the range 0 - 3');
					}

					if (y < 0 || y > 3) {
						throw new Error('y must be in the range 0 - 3');
					}

					return elements[y * 4 + x];

				};

				this.multiply = function(other) {
					// ?
				};

			}

			Mat4.identity = function() {
				return new Mat4([
					1.0, 0.0, 0.0, 0.0,
					0.0, 1.0, 0.0, 0.0,
					0.0, 0.0, 1.0, 0.0,
					0.0, 0.0, 0.0, 1.0
				]);
			};

			function Vec3(elements) {

				if (elements.length !== 3) {
					throw new Error('Vec3 must have 3 elements');
				}

				this.element = function(i) {

					if (i < 0 || i > 2) {
						throw new Error('i must be in the range 0 - 2');
					}

					return elements[i];
				}

				this.x = function() {
					return this.element(0);
				};

				this.y = function() {
					return this.element(1);
				};

				this.z = function() {
					return this.element(2);
				};

			}*/

			function Vertex(x, y, z) {

				this.x = function() {
					return x;
				};

				this.y = function() {
					return y;
				};

				this.z = function() {
					return z;
				};

				/*this.toVec3 = function() {
					return new Vec3([x, y, z]);
				};*/

			}

			function Triangle(a, b, c) {

				this.a = function() {
					return a;
				};

				this.b = function() {
					return b;
				};

				this.c = function() {
					return c;
				};

			}

			function Polygon(vertices) {

				this.count = function() {
					return vertices.length;
				};

				this.vertex = function(i) {
					if (i < 0) {
						throw new Error('Vertex index must be a positive integer')
					}
					if (i >= vertices.length) {
						throw new Error('Vertex index out of bounds');
					}

					return vertices[i];
				};

			}

			function drawPolygon(context, polygon, fx, fy) {
				context.beginPath();
				context.moveTo(fx(polygon.vertex(0)), -1 * fy(polygon.vertex(0)));
				for (var i = 1; i < polygon.count(); ++i) {
					context.lineTo(fx(polygon.vertex(i)), -1 * fy(polygon.vertex(i)));
				}
				context.closePath();
				context.stroke();
			}

			var modelVerts = [
				new Vertex(-1.0, -1.0, -1.0), // 0 FBL
				new Vertex( 1.0, -1.0, -1.0), // 1 FBR

				new Vertex(-1.0, -1.0,  1.0), // 2 RBL
				new Vertex( 1.0, -1.0,  1.0), // 3 RBR
				
				new Vertex(-1.0,  1.0, -1.0), // 4 FTL
				new Vertex( 1.0,  1.0, -1.0), // 5 FTR

				new Vertex(-1.0,  1.0,  1.0), // 6 RTL
				new Vertex( 1.0,  1.0,  1.0)  // 7 RTR
			];

			var modelPolygons = [
				new Polygon([modelVerts[0], modelVerts[1], modelVerts[5], modelVerts[4]]), // FRONT
				new Polygon([modelVerts[2], modelVerts[3], modelVerts[7], modelVerts[6]]), // REAR
				new Polygon([modelVerts[0], modelVerts[1], modelVerts[3], modelVerts[2]]), // BOTTOM
				new Polygon([modelVerts[4], modelVerts[5], modelVerts[7], modelVerts[6]]), // TOP
				new Polygon([modelVerts[0], modelVerts[2], modelVerts[6], modelVerts[4]]), // LEFT
				new Polygon([modelVerts[1], modelVerts[3], modelVerts[7], modelVerts[5]])  // RIGHT
			];

			// Basic scaled projection discarding depth / z value
			(function() {

				var canvas = document.getElementById('canvas-1');
				var context = canvas.getContext('2d');

				canvas.width = "640";
				canvas.height = "480";

				context.translate(canvas.width / 2, canvas.height / 2); // 0 should be in the centre
				context.strokeStyle = '#FFFFFF';

				var modelSize = canvas.width / 2;
				var scale = modelSize / 2;

				var fx = function(vertex) {
					return vertex.x() * scale;
				};

				var fy = function(vertex) {
					return vertex.y() * scale;
				};

				for (var i = 0; i < modelPolygons.length; ++i) {
					drawPolygon(context, modelPolygons[i], fx, fy);
				}

			}) ();

			(function() {
				
				var canvas = document.getElementById('canvas-2');
				var context = canvas.getContext('2d');

				canvas.width = "640";
				canvas.height = "480";

				context.translate(canvas.width / 2, canvas.height / 2); // 0 should be in the centre
				context.strokeStyle = '#FFFFFF';
				
				var modelSize = canvas.width / 2;
				var scale = modelSize / 2;
				var a = 0.2;
				var b = 0.2;

				var fx = function(vertex) {
					return (vertex.x() + vertex.z() * a) * scale;
				};

				var fy = function(vertex) {
					return (vertex.y() + vertex.z() * b) * scale;
				};

				for (var i = 0; i < modelPolygons.length; ++i) {
					drawPolygon(context, modelPolygons[i], fx, fy);
				}

			}) ();

			(function() {

				var canvas = document.getElementById('canvas-3');
				var context = canvas.getContext('2d');

				canvas.width = "640";
				canvas.height = "480";

				context.translate(canvas.width / 2, canvas.height / 2); // 0 should be in the centre
				context.strokeStyle = '#FFFFFF';

				var modelSize = canvas.width / 4;
				var scale = modelSize / 2;
				var angle = Math.PI / 6; // 30 degrees
				var a = Math.cos(angle);
				var b = Math.sin(angle);

				var fx = function(vertex) {
					return (vertex.x() + vertex.z() * a) * scale;
				};

				var fy = function(vertex) {
					return (vertex.y() + vertex.z() * b) * scale;
				};

				for (var i = 0; i < modelPolygons.length; ++i) {
					drawPolygon(context, modelPolygons[i], fx, fy);
				}

			}) ();

			(function() {

				var canvas = document.getElementById('canvas-4');
				var context = canvas.getContext('2d');

				canvas.width = "640";
				canvas.height = "480";

				context.translate(canvas.width / 2, canvas.height / 2); // 0 should be in the centre
				context.strokeStyle = '#FFFFFF';

				var modelSize = canvas.width / 4;
				var scale = modelSize / 2;
				var angle = Math.PI / 6; // 30 degrees
				var a = Math.cos(angle) / 2;
				var b = Math.sin(angle) / 2;

				var fx = function(vertex) {
					return (vertex.x() + vertex.z() * a) * scale;
				};

				var fy = function(vertex) {
					return (vertex.y() + vertex.z() * b) * scale;
				};

				for (var i = 0; i < modelPolygons.length; ++i) {
					drawPolygon(context, modelPolygons[i], fx, fy);
				}

			}) ();

			(function() {

				var canvas = document.getElementById('canvas-5');
				var context = canvas.getContext('2d');

				canvas.width = "640";
				canvas.height = "480";

				context.translate(canvas.width / 2, canvas.height / 2); // 0 should be in the centre
				context.strokeStyle = '#FFFFFF';

				var modelSize = canvas.width / 4;
				var scale = modelSize / 2;
				var angle = Math.PI / 6; // 30 degrees
				var a = Math.cos(angle) * 2 / 3;
				var b = Math.sin(angle) * 2 / 3;

				var fx = function(vertex) {
					return (vertex.x() + vertex.z() * a) * scale;
				};

				var fy = function(vertex) {
					return (vertex.y() + vertex.z() * b) * scale;
				};

				for (var i = 0; i < modelPolygons.length; ++i) {
					drawPolygon(context, modelPolygons[i], fx, fy);
				}

			}) ();

			(function() {

				var canvas = document.getElementById('canvas-6');
				var context = canvas.getContext('2d');

				canvas.width = "640";
				canvas.height = "480";

				context.translate(canvas.width / 2, canvas.height / 2); // 0 should be in the centre
				context.strokeStyle = '#FFFFFF';

				var modelSize = canvas.width / 4;
				var scale = modelSize / 2;
				var angle = Math.PI / 6; // 30 degrees
				var a = Math.cos(angle);
				var b = Math.sin(angle);

				var fx = function(vertex) {
					return (vertex.x() * a + vertex.z() * a) * scale;
				};

				var fy = function(vertex) {
					return (vertex.y() + vertex.z() * b - vertex.x() * b) * scale;
				};

				for (var i = 0; i < modelPolygons.length; ++i) {
					drawPolygon(context, modelPolygons[i], fx, fy);
				}

			}) ();

		</script>
	</body>
</html>
