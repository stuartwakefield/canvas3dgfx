<!DOCTYPE html>
<html>
	<head>
		<title>Projection of Three-Dimensional Models in JavaScript and HTML5 Canvas</title>
		<link rel="stylesheet" media="screen" href="main.css"/>
		<script src="ga.js" async></script>
		<script>

			function Vertex(x, y, z) {

				this.x = function() {
					return x;
				};

				this.y = function() {
					return y;
				};

				this.z = function() {
					return z;
				};

			}

			function Polygon(vertices) {

				this.count = function() {
					return vertices.length;
				};

				this.vertex = function(i) {
					if (i < 0) {
						throw new Error('Vertex index must be a positive integer')
					}
					if (i >= vertices.length) {
						throw new Error('Vertex index out of bounds');
					}

					return vertices[i];
				};

			}

			function drawPolygon(context, polygon, fx, fy) {
				context.beginPath();
				context.moveTo(fx(polygon.vertex(0)), -1 * fy(polygon.vertex(0)));
				for (var i = 1; i < polygon.count(); ++i) {
					context.lineTo(fx(polygon.vertex(i)), -1 * fy(polygon.vertex(i)));
				}
				context.closePath();
				context.stroke();
			}

			var orthogonal = {

				gx: function(scale) {
					return function(vertex) {
						return vertex.x() * scale;
					};
				},

				gy: function(scale) {
					return function(vertex) {
						return vertex.y() * scale;
					};
				}

			};

			var oblique = {

				gx: function(scale, zc) {
					return function(vertex) {
						return (vertex.x() + vertex.z() * zc) * scale;
					};
				},

				gy: function(scale, zc) {
					return function(vertex) {
						return (vertex.y() + vertex.z() * zc) * scale;
					};
				}

			};

			var isometric = {

				gx: function(scale, c) {
					return function(vertex) {
						return (vertex.x() * c + vertex.z() * c) * scale;
					};
				},

				gy: function(scale, c) {
					return function(vertex) {
						return (vertex.y() + vertex.z() * c - vertex.x() * c) * scale;
					};
				}

			}

			function drawPolygon2(context, polygon, matrix, fx, fy) {
				context.beginPath();
				var vertex = Vertex.transform(polygon.vertex(0), matrix);
				context.moveTo(fx(vertex), -1 * fy(vertex));
				for (var i = 1; i < polygon.count(); ++i) {
					vertex = Vertex.transform(polygon.vertex(i), matrix);
					context.lineTo(fx(vertex), -1 * fy(vertex));
				}
				context.closePath();
				context.stroke();
			}

			Vertex.transform = function(vertex, matrix) {
				return Vertex.fromVec3(
					matrix.multiply(
						Vertex.toVec3(vertex)
					)
				);
			};

			function Vec3(elements) {

				if (elements.length !== 3) {
					throw new Error('Vec3 must have 3 elements');
				}

				this.element = function(i) {

					if (i < 0 || i > 2) {
						throw new Error('i must be in the range 0 - 2');
					}

					return elements[i];

				};

				this.multiply = function(matrix) {

					if (!(matrix instanceof Mat3)) {
						throw new Error('matrix must be a Mat3');
					}

					return matrix.multiply(this);

				}

			}

			Vertex.toVec3 = function(vertex) {
				return new Vec3([vertex.x(), vertex.y(), vertex.z()]);
			};

			Vertex.fromVec3 = function(vector) {
				return new Vertex(vector.element(0), vector.element(1), vector.element(2));
			};

			function Mat3(elements) {

				if (elements.length !== 9) {
					throw new Error('Mat3 must have 9 elements');
				}

				this.element = function(x, y) {

					if (x < 0 || x > 2) {
						throw new Error('x must be in the range 0 -2');
					}

					if (y < 0 || y > 2) {
						throw new Error('y must be in the range 0 - 2');
					}

					return elements[y * 3 + x];

				};

				this.multiply = function(other) {

					if (!(other instanceof Vec3)
							&& !(other instanceof Mat3)) {
						throw new Error('vector must be either a Vec3 or Mat3');
					}

					if (other instanceof Vec3) {

						var elements = [];
						for (var y = 0; y < 3; ++y) {
							var sum = 0;
							for (var x = 0; x < 3; ++x) {
								sum += other.element(x) * this.element(x, y);
							}
							elements.push(sum);
						}

						return new Vec3(elements);
					} else {

						var elements = [];
						for (var z = 0; z < 3; ++z) {
							for (var y = 0; y < 3; ++y) {
								var sum = 0;
								for (var x = 0; x < 3; ++x) {
									sum += other.element(y, x) * this.element(x, z);
								}
								elements.push(sum);
							}
						}

						return new Mat3(elements);
					}

				};

			}

			Mat3.identity = function() {
				return new Mat3([
					1.0, 0.0, 0.0,
					0.0, 1.0, 0.0,
					0.0, 0.0, 1.0
				]);
			}

			Mat3.rotationX = function(angle) {
				var a = Math.cos(angle);
				var b = Math.sin(angle);
				return new Mat3([
					1.0, 0.0, 0.0,
					0.0,   a,  -b,
					0.0,   b,   a,
				]);
			};

			Mat3.rotationY = function(angle) {
				var a = Math.cos(angle);
				var b = Math.sin(angle);
				return new Mat3([
					  a, 0.0,   b,
					0.0, 1.0, 0.0,
					 -b, 0.0,   a,
				]);
			};


			Mat3.rotationZ = function(angle) {
				var a = Math.cos(angle);
				var b = Math.sin(angle);
				return new Mat3([
					  a,  -b, 0.0,
					  b,   a, 0.0,
					0.0, 0.0, 1.0,
				]);
			};

			Mat3.isometric = function(angle) {
				var a = Math.cos(angle);
				var b = Math.sin(angle);
				return new Mat3([
					 a, 0, a,
					-b, 1, b,
					 0, 0, 0
				]);
			};

			function drawAxisIndicator(context, matrix) {

				context.save();

				context.textBaseline = 'middle';
				context.textAlign = 'center';

				context.strokeStyle = '#F06';
				context.fillStyle = '#F06';

				var x = new Vec3([30.0, 0.0, 0.0]).multiply(matrix);
				context.fillText('X', x.element(0), -1 * x.element(1));
				drawLineFromVectors(
					context,
					new Vec3([0.0, 0.0, 0.0]).multiply(matrix),
					new Vec3([20.0, 0.0, 0.0]).multiply(matrix)
				);

				context.strokeStyle = '#F90';
				context.fillStyle = '#F90';

				var y = new Vec3([0.0, 30.0, 0.0]).multiply(matrix);
				context.fillText('Y', y.element(0), -1 * y.element(1));
				drawLineFromVectors(
					context,
					new Vec3([0.0, 0.0, 0.0]).multiply(matrix),
					new Vec3([0.0, 20.0, 0.0]).multiply(matrix)
				);

				context.strokeStyle = '#09C';
				context.fillStyle = '#09C';

				var z = new Vec3([0.0, 0.0, 30.0]).multiply(matrix);
				context.fillText('Z', z.element(0), -1 * z.element(1));
				drawLineFromVectors(
					context,
					new Vec3([0.0, 0.0, 0.0]).multiply(matrix),
					new Vec3([0.0, 0.0, 20.0]).multiply(matrix)
				);

				context.restore();

			};

			function drawLineFromVectors(context, a, b) {
				context.beginPath();
				context.moveTo(a.element(0), -1 * a.element(1));
				context.lineTo(b.element(0), -1 * b.element(1));
				context.stroke();
			};

			var loop = {
				fns: [],
				start: function() {
					var fns = this.fns;
					setInterval(function() {
						for (var i = 0; i < fns.length; ++i) {
							fns[i]();
						}
					}, 25);
				}
			}

		</script>
	</head>
	<body>

		<script>

			var modelVerts1 = [
				new Vertex(-1.0, -1.0, -1.0), // 0 FBL
				new Vertex( 1.0, -1.0, -1.0), // 1 FBR

				new Vertex(-1.0, -1.0,  1.0), // 2 RBL
				new Vertex( 1.0, -1.0,  1.0), // 3 RBR
				
				new Vertex(-1.0,  1.0, -1.0), // 4 FTL
				new Vertex( 1.0,  1.0, -1.0), // 5 FTR

				new Vertex(-1.0,  1.0,  1.0), // 6 RTL
				new Vertex( 1.0,  1.0,  1.0)  // 7 RTR
			];

			var modelPolygons1 = [
				new Polygon([
					modelVerts1[0],
					modelVerts1[1],
					modelVerts1[5],
					modelVerts1[4]
				]), // FRONT
				new Polygon([
					modelVerts1[2],
					modelVerts1[3],
					modelVerts1[7],
					modelVerts1[6]
				]), // REAR
				new Polygon([
					modelVerts1[0],
					modelVerts1[1],
					modelVerts1[3],
					modelVerts1[2]
				]), // BOTTOM
				new Polygon([
					modelVerts1[4],
					modelVerts1[5],
					modelVerts1[7],
					modelVerts1[6]
				]), // TOP
				new Polygon([
					modelVerts1[0],
					modelVerts1[2],
					modelVerts1[6],
					modelVerts1[4]
				]), // LEFT
				new Polygon([
					modelVerts1[1],
					modelVerts1[3],
					modelVerts1[7],
					modelVerts1[5]
				])  // RIGHT
			];

			// Pencil
			/*var modelVerts2 = [
				new Vertex( 0.0, -3.0, -0.5 ),
				new Vertex( 0.5, -3.0, -0.25),
				new Vertex( 0.5, -3.0,  0.25),
				new Vertex( 0.0, -3.0,  0.5),
				new Vertex(-0.5, -3.0,  0.25),
				new Vertex(-0.5, -3.0, -0.25),

				new Vertex( 0.0,  2.0, -0.5 ),
				new Vertex( 0.5,  2.0, -0.25),
				new Vertex( 0.5,  2.0,  0.25),
				new Vertex( 0.0,  2.0,  0.5),
				new Vertex(-0.5,  2.0,  0.25),
				new Vertex(-0.5,  2.0, -0.25),

				new Vertex( 0.0,  3.0,  0.0)
			];

			var modelPolygons2 = [
				new Polygon([
					modelVerts2[0],
					modelVerts2[1],
					modelVerts2[2],
					modelVerts2[3],
					modelVerts2[4],
					modelVerts2[5]
				]),

				new Polygon([
					modelVerts2[0],
					modelVerts2[1],
					modelVerts2[7],
					modelVerts2[6]
				]),
				new Polygon([
					modelVerts2[1],
					modelVerts2[2],
					modelVerts2[8],
					modelVerts2[7]
				]),
				new Polygon([
					modelVerts2[2],
					modelVerts2[3],
					modelVerts2[9],
					modelVerts2[8]
				]),
				new Polygon([
					modelVerts2[3],
					modelVerts2[4],
					modelVerts2[10],
					modelVerts2[9]
				]),
				new Polygon([
					modelVerts2[4],
					modelVerts2[5],
					modelVerts2[11],
					modelVerts2[10]
				]),
				new Polygon([
					modelVerts2[5],
					modelVerts2[0],
					modelVerts2[6],
					modelVerts2[11]
				]),

				new Polygon([
					modelVerts2[6],
					modelVerts2[7],
					modelVerts2[12]
				]),
				new Polygon([
					modelVerts2[7],
					modelVerts2[8],
					modelVerts2[12]
				]),
				new Polygon([
					modelVerts2[8],
					modelVerts2[9],
					modelVerts2[12]
				]),
				new Polygon([
					modelVerts2[9],
					modelVerts2[10],
					modelVerts2[12]
				]),
				new Polygon([
					modelVerts2[10],
					modelVerts2[11],
					modelVerts2[12]
				]),
				new Polygon([
					modelVerts2[11],
					modelVerts2[6],
					modelVerts2[12]
				])
			]*/

			modelPolygons = modelPolygons1;

		</script>

		<div class="header">
			<h1>Projection of Three-Dimensional Models in JavaScript and HTML5 Canvas</h2>
			<p class="author"><a href="http://stuartwakefield.co.uk">Stuart Wakefield</a> (<a href="https://plus.google.com/u/0/105620785565675144505?rel=author">g+</a>)</p>
		</div>

		<p class="note">This article makes use of SVG images and the HTML canvas element, some older browsers are unable to support these features. Check your browser at <a href="http://html5test.com/">html5test.com</a></p>

		<h2>Orthogonal projection</h2>
		<p>This projection discards one of the axis information to create a two-dimensional representation.</p>
		<canvas id="canvas-1"></canvas>
		<script>

			// Basic scaled projection discarding depth / z value
			(function() {

				var canvas = document.getElementById('canvas-1');
				var context = canvas.getContext('2d');

				canvas.width = "640";
				canvas.height = "240";

				context.translate(canvas.width / 2, canvas.height / 2); // 0 should be in the centre
				context.strokeStyle = '#222222';

				var modelSize = canvas.width / 4;
				var scale = modelSize / 2;
				var fx = orthogonal.gx(scale);
				var fy = orthogonal.gy(scale);

				for (var i = 0; i < modelPolygons.length; ++i) {
					drawPolygon(context, modelPolygons[i], fx, fy);
				}

			}) ();

		</script>

		<h2>Oblique projection</h2>
		<img src="oblique-projection.svg" alt="(x,y)=(x+az,y+bz)" class="svg"/>
		<canvas id="canvas-2"></canvas>
		<script>

			(function() {
				
				var canvas = document.getElementById('canvas-2');
				var context = canvas.getContext('2d');

				canvas.width = "640";;
				canvas.height = "240";

				context.translate(canvas.width / 2, canvas.height / 2); // 0 should be in the centre
				context.strokeStyle = '#222222';

				var modelSize = canvas.width / 4;
				var scale = modelSize / 2;
				var c = 0.2;
				var fx = oblique.gx(scale, c);
				var fy = oblique.gy(scale, c);

				for (var i = 0; i < modelPolygons.length; ++i) {
					drawPolygon(context, modelPolygons[i], fx, fy);
				}

			}) ();

		</script>

		<h3>Cavalier projection</h3>
		<img src="cavalier-projection.svg" alt="a=cos &theta;,b=sin &theta;,(x,y)=(x+az,y+bz)=(x+z cos &theta;,y+z sin &theta;)" class="svg"/>
		<p>Cavalier projection is an oblique projection where the z length is preserved.</p>

		<canvas id="canvas-3"></canvas>
		<script>

			(function() {

				var canvas = document.getElementById('canvas-3');
				var context = canvas.getContext('2d');

				canvas.width = "640";;
				canvas.height = "320";

				context.translate(canvas.width / 2, canvas.height / 2); // 0 should be in the centre
				context.strokeStyle = '#222222';

				var modelSize = canvas.width / 4;
				var scale = modelSize / 2;
				var angle = Math.PI / 6; // 30 degrees
				var a = Math.cos(angle);
				var b = Math.sin(angle);
				var fx = oblique.gx(scale, a);
				var fy = oblique.gy(scale, b);

				for (var i = 0; i < modelPolygons.length; ++i) {
					drawPolygon(context, modelPolygons[i], fx, fy);
				}

			}) ();

		</script>

		<h3>Cabinet projection</h3>
		<p>The length along the z axis is shortened by a half or two thirds to provide a more realistic representation of the proportions.</p>
		<img src="cabinet-projection-half.svg" class="svg"/>
		<canvas id="canvas-4"></canvas>
		<script>

			(function() {

				var canvas = document.getElementById('canvas-4');
				var context = canvas.getContext('2d');

				canvas.width = "640";;
				canvas.height = "320";

				context.translate(canvas.width / 2, canvas.height / 2); // 0 should be in the centre
				context.strokeStyle = '#222222';

				var modelSize = canvas.width / 4;
				var scale = modelSize / 2;
				var angle = Math.PI / 6; // 30 degrees
				var a = Math.cos(angle) / 2;
				var b = Math.sin(angle) / 2;
				var fx = oblique.gx(scale, a);
				var fy = oblique.gy(scale, b);

				for (var i = 0; i < modelPolygons.length; ++i) {
					drawPolygon(context, modelPolygons[i], fx, fy);
				}

			}) ();

		</script>
		<img src="cabinet-projection-two-thirds.svg" class="svg"/>
		<canvas id="canvas-5"></canvas>
		<script>

			(function() {

				var canvas = document.getElementById('canvas-5');
				var context = canvas.getContext('2d');

				canvas.width = "640";;
				canvas.height = "320";

				context.translate(canvas.width / 2, canvas.height / 2); // 0 should be in the centre
				context.strokeStyle = '#222222';

				var modelSize = canvas.width / 4;
				var scale = modelSize / 2;
				var angle = Math.PI / 6; // 30 degrees
				var a = Math.cos(angle) * 2 / 3;
				var b = Math.sin(angle) * 2 / 3;
				var fx = oblique.gx(scale, a);
				var fy = oblique.gy(scale, b);

				for (var i = 0; i < modelPolygons.length; ++i) {
					drawPolygon(context, modelPolygons[i], fx, fy);
				}

			}) ();

		</script>

		<h2>Axonometric projection</h2>
		<h3>Isometric projection</h3>
		<img src="isometric-projection.svg" class="svg"/>
		<pre class="code">var a = Math.cos(angle);
<!--		-->var b = Math.sin(angle);
<!--		-->var fx = function(vertex) {
<!--		-->  return vertex.x() * a + vertex.z() * a;
<!--		-->};
<!--		-->var fy = function(vertex) {
<!--		-->  return vertex.y() + vertex.z() * b - vertex.x() * b;
<!--		-->};</pre>
		<canvas id="canvas-6"></canvas>
		<script>

			(function() {

				var canvas = document.getElementById('canvas-6');
				var context = canvas.getContext('2d');

				canvas.width = "640";;
				canvas.height = "320";

				context.translate(canvas.width / 2, canvas.height / 2); // 0 should be in the centre
				context.strokeStyle = '#222222';

				var modelSize = canvas.width / 4;
				var scale = modelSize / 2;
				var angle = Math.PI / 6; // 30 degrees
				var a = Math.cos(angle);
				var b = Math.sin(angle);

				var fx = isometric.gx(scale, a);
				var fy = isometric.gy(scale, b);

				for (var i = 0; i < modelPolygons.length; ++i) {
					drawPolygon(context, modelPolygons[i], fx, fy);
				}

			}) ();

		</script>
		<p>Projection can also be expressed more elegantly using a transformation matrix.</p>
		<img src="isometric-projection-matrix.svg" class="svg"/>
		<pre class="code">var a = Math.cos(angle);
<!--		-->var b = Math.sin(angle);
<!--		-->return new Mat3([
<!--		-->   a, 0, a,
<!--		-->  -b, 1, b,
<!--		-->   0, 0, 0
<!--		-->]);</pre>
		<canvas id="canvas-6a"></canvas>
		<script>

			(function() {

				var canvas = document.getElementById('canvas-6a');
				var context = canvas.getContext('2d');

				canvas.width = "640";;
				canvas.height = "320";

				context.translate(canvas.width / 2, canvas.height / 2); // 0 should be in the centre
				context.strokeStyle = '#222222';

				var modelSize = canvas.width / 4;
				var scale = modelSize / 2;
				var angle = Math.PI / 6; // 30 degrees
				var transform = Mat3.isometric(angle);

				var fx = function(vertex) { return vertex.x() * scale; };
				var fy = function(vertex) { return vertex.y() * scale; };

				for (var i = 0; i < modelPolygons.length; ++i) {
					drawPolygon2(context, modelPolygons[i], transform, fx, fy);
				}

			}) ();

		</script>

		<h2>Rotation transformations</h2>
		<p>Using a matrix</p>
		<img src="rotation-transform-matrices.svg" class="svg"/>
		<canvas id="canvas-7"></canvas>
		<script>

			(function() {

				var canvas = document.getElementById('canvas-7');
				var context = canvas.getContext('2d');

				canvas.width = "640";;
				canvas.height = "240";

				context.translate(canvas.width / 2, canvas.height / 2); // 0 should be in the centre
				context.strokeStyle = '#222222';

				var modelSize = canvas.width / 4;
				var scale = modelSize / 2;
				var step = 0;

				loop.fns.push(function() {
					context.clearRect(- canvas.width / 2, - canvas.height / 2, canvas.width, canvas.height);
					var transform = Mat3.rotationX(Math.PI * step++ / 128);

					var fx = function(vertex) {
						return vertex.x() * scale;
					};

					var fy = function(vertex) {
						return vertex.y() * scale;
					};

					drawAxisIndicator(context, transform);

					for (var i = 0; i < modelPolygons.length; ++i) {
						drawPolygon2(context, modelPolygons[i], transform, fx, fy);
					}
				});

			}) ();

		</script>
		<canvas id="canvas-8"></canvas>
		<script>

			(function() {

				var canvas = document.getElementById('canvas-8');
				var context = canvas.getContext('2d');

				canvas.width = "640";;
				canvas.height = "240";

				context.translate(canvas.width / 2, canvas.height / 2); // 0 should be in the centre
				context.strokeStyle = '#222222';

				var modelSize = canvas.width / 4;
				var scale = modelSize / 2;
				var step = 0;

				loop.fns.push(function() {
					context.clearRect(- canvas.width / 2, - canvas.height / 2, canvas.width, canvas.height);
					var transform = Mat3.rotationY(Math.PI * step++ / 128);

					var fx = function(vertex) {
						return vertex.x() * scale;
					};

					var fy = function(vertex) {
						return vertex.y() * scale;
					};

					drawAxisIndicator(context, transform);

					for (var i = 0; i < modelPolygons.length; ++i) {
						drawPolygon2(context, modelPolygons[i], transform, fx, fy);
					}
				});

			}) ();

		</script>
		<canvas id="canvas-9"></canvas>
		<script>

			(function() {

				var canvas = document.getElementById('canvas-9');
				var context = canvas.getContext('2d');

				canvas.width = "640";
				canvas.height = "240";

				context.translate(canvas.width / 2, canvas.height / 2); // 0 should be in the centre
				context.strokeStyle = '#222222';

				var modelSize = canvas.width / 4;
				var scale = modelSize / 2;
				var step = 0;

				loop.fns.push(function() {
					context.clearRect(- canvas.width / 2, - canvas.height / 2, canvas.width, canvas.height);
					var transform = Mat3.rotationZ(Math.PI * step++ / 128);

					var fx = function(vertex) {
						return vertex.x() * scale;
					};

					var fy = function(vertex) {
						return vertex.y() * scale;
					};

					drawAxisIndicator(context, transform);

					for (var i = 0; i < modelPolygons.length; ++i) {
						drawPolygon2(context, modelPolygons[i], transform, fx, fy);
					}
				});

			}) ();

		</script>
		<p>Translation around multiple axis can be achieved simply by multiplying rotation matrices together to produce the transform matrix, which creates a traditional, roll, pitch, yaw rotation model.</p>
		<img src="general-rotation-through-multiplication.svg" class="svg"/>
		<canvas id="canvas-10"></canvas>
		<script>

			(function() {

				var canvas = document.getElementById('canvas-10');
				var context = canvas.getContext('2d');

				canvas.width = "640";;
				canvas.height = "320";

				context.translate(canvas.width / 2, canvas.height / 2); // 0 should be in the centre
				context.strokeStyle = '#222222';

				var modelSize = canvas.width / 4;
				var scale = modelSize / 2;
				var step = 0;

				loop.fns.push(function() {
					context.clearRect(- canvas.width / 2, - canvas.height / 2, canvas.width, canvas.height);
					var transform = Mat3.rotationZ(Math.PI * step / 128)
						.multiply(Mat3.rotationY(Math.PI * step / 256))
						.multiply(Mat3.rotationX(Math.PI * step++ / 512));

					var fx = function(vertex) {
						return vertex.x() * scale;
					};

					var fy = function(vertex) {
						return vertex.y() * scale;
					};

					drawAxisIndicator(context, transform);

					for (var i = 0; i < modelPolygons.length; ++i) {
						drawPolygon2(context, modelPolygons[i], transform, fx, fy);
					}
				});

			}) ();

		</script>
		<script>loop.start();</script>

		<!--<p>Next:</p>
		<ul>
			<li>Perspective</li>
			<li>Z buffer</li>
			<li>Ambient lighting</li>
			<li>Polygon normal lighting</li>
			<li>Meshes</li>
			<li>Generating meshes from shapes</li>
			<li>Representing curves</li>
			<li>Phong lighting</li>
			<li>Bump mapping</li>
		</ul>-->

		<h2>Bibliography</h2>
		<ul>
			<li>Carlbrom, I., &amp; Paciorek, J. <em><a href="http://www.cs.uns.edu.ar/cg/clasespdf/p465carlbom.pdf">Planar Geometric Projections and Viewing Transformations</a></em>. ACM Computing Surveys, Vol. 10, No. 4. 1978.</li>
			<li><em>Multiple authors</em>. <em><a href="http://en.wikipedia.org/w/index.php?title=3D_projection&amp;oldid=608680154">3D projection</a></em>. Wikipedia. 2014.</li>
			<li><em>Multiple authors</em>. <em><a href="http://en.wikipedia.org/w/index.php?title=Rotation_matrix&amp;oldid=610870750">Rotation matrix</a></em>. Wikipedia. 2014.</li>
			<!--<li>Continuous Shading of Curved Surfaces - Henri Gouraud</li>
			<li>Illumination for Computer Generated Pictures - Bui Tuong Phong</li>
			<li>Fast Phong Shading - Gary Bishop and David M Weimer</li>
			<li>Improved Specular Highlights with Adaptive Shading - Youngkwan Cho, Ulrich Neumann and Jongwook Woo</li>
			<li>Relief Texture Mapping - Manuel M Oliveira, Gary Bishop and David McAllister</li>-->
		</ul>
	</body>
</html>
